# TIL 2023-08-17

## 큐(Queue)

### 선형큐

##### 스택과 마찬가지로 삽입과 삭제의 위치가 제한적인 자료구조

뒤쪽으로만 삽입하고 앞에서만 삭제하는 구조

#### 선입선출구조(FIFO : First In First Out)

큐에 삽입한 순서대로 원소가 저장되어, 가장먼저 삽입된 원소는 가장 먼저 삭제된다.

저장된 원소 중 첫번째 원소(삭제된 위치) : 머리 (Front)

저장된 원소 중 마지막 원소 : 꼬리 (Rear)

삽입 : enQueue

삭제 : deQueue

|     연산      |                        기능                        |
| :-----------: | :------------------------------------------------: |
| enQueue(item) |    큐의 뒤쪽(rear 다음)에 원소를 삽입하는 연산     |
|   deQueue()   | 큐의 앞쪽(front)에서 원소를 삭제하고 반환하는 연산 |
| createQueue() |           공백 상태의 큐를 생성하는 연산           |
|   isEmpty()   |         큐가 공백상태인지를 확인하는 연산          |
|   isFull()    |         큐가 포화상태인지를 확인하는 연산          |
|    Qpeek()    | 큐의 앞쪽(front)에서 원소를 삭제없이 반환하는 연산 |

1. 공백 큐 생성 : createQueue()	[ ]
2. 원소 A 삽입 : enQueue(A) [A]
3. 원소 B 삽입 : enQueue(B) [A,B]
4. 원소 반환/삭제 : deQueue() [B]
5. 원소 C 삽입 : enQueue(C) [B,C]
6. 원소 반환/삭제 : deQueue() [C]
7. 원소 반환/삭제 : deQueue() [ ]

#### 선형큐

1차원 배열을 이용한 큐

큐의 크기 = 배열의 크기

초기상태 : front = rear = -1

공백상태 : front == rear

포화상태 : rear == n-1 (n : 배열의 크기, n-1 : 배열의 마지막 인덱스)

```py
def enQueue(item):
    global rear
    if isFull():
        print('Queue_Full')
    else:
        rear += 1
        Q[rear] = item
        
def deQueue():
    global front
    if(isEmpty):
        print('Queue_Empty')
    else:
        front += 1
        return Q[front]
    
```

#### 선형 큐의 문제점

선형 큐를 이용하여 원소의 삽입과 삭제를 계속할 경우, 배열의 앞부분에 활용 할 수 있는 공간이 있음에도 불구하고 rear = n-1인 상태 즉, 포화상태로 인식하여 더이상 삽입을 수행 할 수 없음

- 방법1
  - 매 연산이 이루어질 때마다 저장된 원소들의 배열의 앞부분으로 모두 이동
  - 원소 이동에 많은 시간 소요, 큐의 효율성 급감
- 방법2
  - 1차원 배열을 사용하되 논리적으로는 배열의 처음과 끝이 연결되어 원형 형태의 큐를 이룬다고 가정
  - 원형 큐의 논리적인 구조

#### 원형 큐

초기 공백 상태 : front = rear = 0

Index의 순환

front와 rear의 위치가 배열의 마지막 인덱스인 n-1를 가리킨 후 그 다음에는 논리적 순환을 이루어 배열의 처음 인덱스인 0으로 이동

이를 위해 나머지 연산자 mod 사용

|        |        삽입 위치        |         삭제 위치         |
| :----: | :---------------------: | :-----------------------: |
| 선형큐 |     rear = rear + 1     |     front = front + 1     |
| 원형큐 | rear = (rear + 1) mod n | front = (front + 1) mod n |

