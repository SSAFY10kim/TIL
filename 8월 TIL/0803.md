# TIL(Today I Learned) 2023-08-02

## List 2

#### 부분집합 생성하기

부분집합의 수 = 2^n개

각 원소를 부분집합에 포함시키거나 포함시키지 않는 2가지 경우를 모든 원소에 적용한 경우의 수

ex) {1,2,3,4} -> 2 * 2 * 2 * 2 = 16가지, 각 자리가 1/0 으로 2진수 배열로 봤을 때

0000 ~ 1111 까지 총 16가지 배열이 생성 -> 즉 0은 포함 X, 1은 포함 O

```py
# 원소 4개 집합의 부분집합
# 각 원소가 부분집합에 포함되었는지를 loop 이용해 확인, 부분집합 생성
def print_subset(bit, arr, n):
    for i in range(n):
        if bit[n]:
            print(arr[i], end = '')
        print(bit)

arr = [1,2,3,4]
bit = [0,0,0,0]
for i in range(2):					# 0번 원소
    bit[0] = i
    for j in range(2):				# 1번 원소
        bit[1] = j
        for k in range(2):			# 2번 원소
            bit[2] = k
            for l in range(2):		# 3번 원소
                bit[3] = l
                print_subset(bit, arr, 4)	# 생성된 부분집합 출력
```

### 비트 연산자

- '&' : 비트 단위로 AND 연산을 한다
- '|' : 비트 단위로 OR 연산을 한다
- '<<' : 피연산자의 비트 열을 왼쪽으로 이동시킨다
- '>>' : 피연산자의 비트 열을 오른쪽으로 이동시킨다

'<<' 연산자

1 << n : 2^n즉, 원소가 n개일 경우 모든 부분집합의 수

'&' 연산자

i & (1<<j) : i의 j번째 비트가 1인지 아닌지를 검사한다



### 정렬되어 있지 않은 경우

#### 이진검색	<< 시험 20점짜리

자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법

목적 키를 찾을 때까지 이진 검색을 순환적으로 반복 수행함으로써 검색 범위를 반으로 줄여가면서 빠르게 검색

**이진 검색을 하기 위해서는 자료가 정렬된 상태여야 한다!**

1. 무조건 정렬된 상태
2. 키가 포함되지 않은쪽은 무시하도록

------------------

#### 알고리즘

```py
# 백준 1931번 / 회의실 배정
n = int(input())
time_s = []

for _ in range(n):
    time = list(map(int, input().split()))
    time_s.append(time)

time_s.sort(key=lambda x: x[1])

# print(time_s)
cur = 0
cnt = 0
for i in range(n):
    cur = time_s[i][1]
    
```



